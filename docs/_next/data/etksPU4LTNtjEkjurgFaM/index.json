{"pageProps":{"posts":[{"id":2470440144,"title":"Consistent Return Types in TypeScript","desc":"Eliminate surprises within your functions","html":"<html><head></head><body><p dir=\"auto\">Imagine we have the following function:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type User = {\n  id: string;\n  permissions: string[];\n};\n\nasync function getUserPermissions(userId: string) {\n  const user = await db.getUserById(userId);\n  if (!user) {\n    return { found: false };\n  }\n\n  return user.permissions;\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">User</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-c1\">id</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-c1\">permissions</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">[</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">async</span> <span class=\"pl-k\">function</span> <span class=\"pl-en\">getUserPermissions</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">userId</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-s1\">user</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">await</span> <span class=\"pl-s1\">db</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">getUserById</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">userId</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-c1\">!</span><span class=\"pl-s1\">user</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">found</span>: <span class=\"pl-c1\">false</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-kos\">}</span>\n\n  <span class=\"pl-k\">return</span> <span class=\"pl-s1\">user</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">permissions</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">The above function has the following implicit return type:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"Promise<string[] | { found: boolean }>\"><pre class=\"notranslate\"><span class=\"pl-smi\">Promise</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">[</span><span class=\"pl-kos\">]</span> <span class=\"pl-c1\">|</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">found</span>: <span class=\"pl-smi\">boolean</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">&gt;</span></pre></div>\n<p dir=\"auto\">The issue is that the two return types have no properties in common, so if you try to do the following:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const userPermissions = await getUserPermissions('123');\nif (!userPermissions.found) { // compiler error here\n  // Handle user not found\n} else if (userPermissions.includes('admin'))\n  // Allow them access\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-s1\">userPermissions</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">await</span> <span class=\"pl-en\">getUserPermissions</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'123'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-c1\">!</span><span class=\"pl-s1\">userPermissions</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">found</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c\">// compiler error here</span>\n  <span class=\"pl-c\">// Handle user not found</span>\n<span class=\"pl-kos\">}</span> <span class=\"pl-k\">else</span> <span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">userPermissions</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">includes</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'admin'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span>\n  <span class=\"pl-c\">// Allow them access</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">the TypeScript compiler will yell at you with:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Property 'found' does not exist on type 'string[] | { found: boolean; }'\"><pre class=\"notranslate\"><code class=\"notranslate\">Property 'found' does not exist on type 'string[] | { found: boolean; }'\n</code></pre></div>\n<h2 dir=\"auto\">The Fix</h2>\n<p dir=\"auto\">The fix will depend on your business logic. In the above scenario, does your app need to distinguish between a user not being found and the user not having the necessary permissions? If not, you should do the following:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"async function getUserPermissions(userId: string) {\n  const user = await db.getUserById(userId);\n  if (!user) {\n    return [];\n  }\n\n  return user.permissions;\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">async</span> <span class=\"pl-k\">function</span> <span class=\"pl-en\">getUserPermissions</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">userId</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-s1\">user</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">await</span> <span class=\"pl-s1\">db</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">getUserById</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">userId</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-c1\">!</span><span class=\"pl-s1\">user</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-kos\">[</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-kos\">}</span>\n\n  <span class=\"pl-k\">return</span> <span class=\"pl-s1\">user</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">permissions</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">This way your function always returns <code class=\"notranslate\">string[]</code>. But if your app <em>does</em> need to distinguish between a user not being found and the user not having the necessary permissions, returning <code class=\"notranslate\">null</code> is probably best:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"async function getUserPermissions(userId: string) {\n  const user = await db.getUserById(userId);\n  if (!user) {\n    return null;\n  }\n\n  return user.permissions;\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">async</span> <span class=\"pl-k\">function</span> <span class=\"pl-en\">getUserPermissions</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">userId</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-s1\">user</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">await</span> <span class=\"pl-s1\">db</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">getUserById</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">userId</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-c1\">!</span><span class=\"pl-s1\">user</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-c1\">null</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-kos\">}</span>\n\n  <span class=\"pl-k\">return</span> <span class=\"pl-s1\">user</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">permissions</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">The return type of <code class=\"notranslate\">Promise&lt;string[] | null&gt;</code> is much easier to work with:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const userPermissions = await getUserPermissions('123');\nif (!userPermissions) {\n  // Handle user not found\n} else if (userPermissions.includes('admin'))\n  // Allow them access\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-s1\">userPermissions</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">await</span> <span class=\"pl-en\">getUserPermissions</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'123'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-c1\">!</span><span class=\"pl-s1\">userPermissions</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-c\">// Handle user not found</span>\n<span class=\"pl-kos\">}</span> <span class=\"pl-k\">else</span> <span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">userPermissions</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">includes</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'admin'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span>\n  <span class=\"pl-c\">// Allow them access</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<h2 dir=\"auto\">One Step Further</h2>\n<p dir=\"auto\">The easiest way to make sure you know exactly what type your function is returning is to explicitly add the return type:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"async function getUserPermissions(userId: string): Promise<string[]> {\n  const user = await db.getUserById(userId);\n  if (!user) {\n    return [];\n  }\n\n  return user.permissions;\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">async</span> <span class=\"pl-k\">function</span> <span class=\"pl-en\">getUserPermissions</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">userId</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">Promise</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">[</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-s1\">user</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">await</span> <span class=\"pl-s1\">db</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">getUserById</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">userId</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-c1\">!</span><span class=\"pl-s1\">user</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-kos\">[</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-kos\">}</span>\n\n  <span class=\"pl-k\">return</span> <span class=\"pl-s1\">user</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">permissions</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">This is a good habit to get into because if you do end up returning something other than <code class=\"notranslate\">string[]</code> in the above function, the TypeScript compiler will yell at you.</p>\n<p dir=\"auto\">If you're using eslint, I would recommend enabling the <a href=\"https://typescript-eslint.io/rules/explicit-function-return-type/\" rel=\"nofollow\" target=\"_blank\">explicit-function-return-type</a> rule, at least as a warning to start. This will ensure that your functions are returning exactly what you expect, with no surprises.</p></body></html>","date":"Aug 16, 2024"},{"id":1590330604,"title":"Simplicity is Key","desc":"Fighting the urge to introduce complexity","html":"<html><head></head><body><p dir=\"auto\">Over the course of my career, I've seen a lot of engineers come and go. This is not uncommon in the tech industry, but it produces a very unfortunate situation for the people who stick around - <strong>complexity increases, but expertise decreases</strong>. Every tool, framework, library, and line of code that is introduced tends to outlast the person who introduced it.</p>\n<p dir=\"auto\">This can be (and hopefully is) mitigated with documentation, but documentation is not a substitute for deep knowledge about how something works. At its best, documentation will send you down the right path, but it's up to you to fill in the inevitable gaps.</p>\n<p dir=\"auto\">The solution to this problem is obvious, although difficult to follow in practice - introduce less stuff. As engineers, we tend to always want to introduce <em>more</em> stuff. REST got you down? Use GraphQL instead! Need to store arbitrary data in your database? NoSQL to the rescue! Need to send messages across applications? Time to onboard Kafka!</p>\n<h2 dir=\"auto\">What's wrong with Kafka and GraphQL?</h2>\n<p dir=\"auto\">To be clear, these are only examples. They all exist because they solve real-world problems, and they each have their place. But adding them (or any other tool) to your stack is not free. Each comes with onboarding costs, monetary costs, and maintenance issues. Eventually, someone at your company is going to need to know how these things work at a low level. You might have a Kafka wizard on your team right now, but will they be there in two years? Maybe, maybe not. But even if they're not, chances are Kafka <em>will</em> still be around. And that is true for the vast majority of the stack.</p>\n<h2 dir=\"auto\">Ask Yourself: Am I solving a real problem?</h2>\n<p dir=\"auto\">Have you ever written code that works perfectly fine, but still leaves you with a nagging feeling? An example might be using an ORM that doesn't allow you to write the most performant SQL query, perhaps even forcing you to run multiple queries instead of one. There's nothing wrong with trying to find a solution to a problem like this, but you have to be careful. How far are you willing to go to solve this problem?  <strong>Is this even a problem that needs to be solved?</strong></p>\n<p dir=\"auto\">Are you doing this for your end users, or are you doing it to make yourself feel better? If you're not careful, you might find yourself burning the next few days test driving alternative ORMs, perhaps even going so far as trying to convince your team of the virtues of adopting a new one. But you need to be able to step back and see the big picture. If everyone on your team likes the current ORM and your less-than-perfect code is still good enough, is introducing a new ORM really the best decision? Is a new ORM a reasonable solution to your original problem?</p>\n<h2 dir=\"auto\">Can we solve the problem with tools we already use?</h2>\n<p dir=\"auto\">Given the astronomical number of tools and libraries that exist today, there is very likely a tool out there built to solve your exact problem. And when you have a perfect match between problem and solution, it's hard not to instinctually reach for that solution.</p>\n<p dir=\"auto\">But are you reaching for a new tool because you actually <em>need</em> it, or because you've heard great things about it and have been looking for a chance to play around with it? Questions that you should ask yourself include:</p>\n<ul dir=\"auto\">\n<li>What is the surface area of this new tool - can it be used in a small corner of the code base to solve a specific problem, or does it span across the entire stack?</li>\n<li>Is the team excited about using this new tool and eager to learn how about how it works, or is one person doing the lion's share of the work, shielding the team from the underlying complexities?</li>\n<li>Most importantly, is there a good enough solution using your existing tools?</li>\n</ul>\n<p dir=\"auto\">That last question is the most important one to ask. Before reaching for a new tool, you should spend time determining if the tools you're already using can solve this problem for you. It doesn't have to be a perfect solution, but a good enough solution with existing tools is almost always better than a perfect solution with a new tool.</p>\n<p dir=\"auto\">I have been guilty of every misstep outlined above, and I've seen others do the same. I've spent plenty of time imagining how some new tool was going to make a whole host of problems go away. What I didn't spend enough time doing was examining the downsides of introducing such a tool and asking myself and the team if it was really worth the cost. And as I've seen over the last five years, those costs add up.</p></body></html>","date":"July 18, 2024"}]},"__N_SSG":true}